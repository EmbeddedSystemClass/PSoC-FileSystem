
#include "project.h"
#include <stdio.h>
#include "FreeRTOS.h"
#include "FreeRTOS_CLI.h"
#include "timers.h"


TaskHandle_t uartTaskHandle;
void uartISR()
{
    
    BaseType_t xHigherPriorityTaskWoken;
    // disable the interrupt
    UART_SetRxInterruptMode(0);
    vTaskNotifyGiveFromISR(uartTaskHandle,&xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    
}

void FreeRTOS_write( void *xConsole, char *pcOutputString, char len )
{
    (void) xConsole;
    for(int i=0;i<len;i++)
        UART_UartPutChar(pcOutputString[i]);
    
}

// Send VT100 Clear Screen and Home Escape Codes
inline void clearScreen()
{
    UART_UartPutString("\033[2J\033[H");
}
#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   configCOMMAND_INT_MAX_OUTPUT_SIZE


BaseType_t testCommand1( int8_t *pcWriteBuffer,
                             size_t xWriteBufferLen,
                             const int8_t *pcCommandString )
{
    (void)xWriteBufferLen;
    (void)pcCommandString;
    strcpy((char *)pcWriteBuffer,"test");
    return pdFALSE;
}
		
    static const CLI_Command_Definition_t xDelCommand =
    {
        "test",
        "test: just print out a test\n",
        testCommand1,
        0
    };

// This is the main task which processes commands from the UART and prints the results
// on the screen.
void uartTask(void *arg)
{
	char pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];
	(void)arg;
	UART_Start();
	clearScreen();
	UART_UartPutString("Command Line & RTC Demo\n");
    
	UART_SetCustomInterruptHandler(uartISR);


    int8_t cRxedChar, cInputIndex = 0;
	BaseType_t xMoreDataToFollow;
	
	RTC_Start();


	FreeRTOS_CLIRegisterCommand( &xDelCommand );	
	
	while(1)
	{
		ulTaskNotifyTake(pdTRUE,portMAX_DELAY);
		
		while(UART_SpiUartGetRxBufferSize()) // if there is data then read and process
		{
			
			cRxedChar = UART_UartGetChar();
       		
			if( cRxedChar == '\r' )
			{
			/* A newline character was received, so the input command string is
			complete and can be processed.  Transmit a line separator, just to
			make the output easier to read. */

            UART_UartPutString("\r");

			/* The command interpreter is called repeatedly until it returns
			pdFALSE.  See the "Implementing a command" documentation for an
			exaplanation of why this is. */
			do
			{
				/* Send the command string to the command interpreter.  Any
				output generated by the command interpreter will be placed in the
				pcOutputString buffer. */
                
				xMoreDataToFollow = FreeRTOS_CLIProcessCommand
							  (
								  pcInputString,   /* The command string.*/
								  pcOutputString,  /* The output buffer. */
								  MAX_OUTPUT_LENGTH/* The size of the output buffer. */
							  );

				/* Write the output generated by the command interpreter to the
				console. */
                    
				FreeRTOS_write( 0, pcOutputString, strlen( pcOutputString ) );

			} while( xMoreDataToFollow != pdFALSE );

			/* All the strings generated by the input command have been sent.
			Processing of the command is complete.  Clear the input string ready
			to receive the next command. */
			cInputIndex = 0;
			memset( pcInputString, 0x00, MAX_INPUT_LENGTH );
		}
		else
		{
			/* The if() clause performs the processing after a newline character
			is received.  This else clause performs the processing if any other
			character is received. */

			if( cRxedChar == '\b' )
			{
				/* Backspace was pressed.  Erase the last character in the input
				buffer - if there are any. */
				if( cInputIndex > 0 )
				{
					cInputIndex--;
					pcInputString[ cInputIndex ] = '\0';
				}
			}
			else
			{
				/* A character was entered.  It was not a new line, backspace
				or carriage return, so it is accepted as part of the input and
				placed into the input buffer.  When a \n is entered the complete
				string will be passed to the command interpreter. */
				if( cInputIndex < MAX_INPUT_LENGTH )
				{
                    UART_UartPutChar(cRxedChar);
					pcInputString[ cInputIndex ] = cRxedChar;
					cInputIndex++;
				}
			}
		}

		}
		// Turn the interrupts back on
		UART_ClearRxInterruptSource(UART_INTR_RX_NOT_EMPTY); 
		UART_SetRxInterruptMode(UART_INTR_RX_NOT_EMPTY);
	}
}


// An example Task
void ledTask(void *arg)
{
    (void)arg;
    while(1)
    {
        RED_Write(~RED_Read());
        vTaskDelay(500);  
    }
}

int main(void)
{
    CyGlobalIntEnable;
    FreeRTOS_Start();

    
    #if ( configUSE_TRACE_FACILITY == 1 )
    vTraceEnable(TRC_START);
    #endif
    
    xTaskCreate(ledTask,"LED Task",configMINIMAL_STACK_SIZE,0,1,0);
    xTaskCreate(uartTask,"UART Task",configMINIMAL_STACK_SIZE*2,0,1,&uartTaskHandle);
    vTaskStartScheduler();  // Will never return
    while(1);               // Eliminate compiler warning
}

